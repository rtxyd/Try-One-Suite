// priority: 89
// type: server

/**
 * @releatedClass
 * AttributeModifier: Java.loadClass('net.minecraft.world.entity.ai.attributes.AttributeModifier')
 * 
 */

/**
 * @loadAfter 90-HandItemLogic
 */

function KeraunoSoulDriver() {
    // 定义全局工具函数
    const startChainReaction = (initialTarget) => {
        console.log('enter2')
        if (!initialTarget.getServer()) return

        let chainCount = 0; // 当前连锁次数
        let initialTriggerTime = initialTarget.tickCount; // 上次触发时间
        let lastPosition = initialTarget.position(); // 初始位置
        const effectTime = 100
        const server = initialTarget.getServer();
        let player = Client.player
        player.tell(`${lastPosition}`)
    
        // 创建定时器（每秒检测一次）
        server.scheduleRepeatingInTicks(5, task => {
            try {
                const currentTime = initialTarget.tickCount
                const currentPos = initialTarget.position();
                const nextTarget = findNearestEntity(initialTarget, 5);

                server.scheduleRepeatingInTicks(1, task2 => {
                    player.tell(`判断实体移动距离`)
                    if (currentPos.distanceTo(lastPosition) >= 2) {
                        //待添加
                        applyDamage()
                    }
                    if (initialTarget.isRemoved() || currentTime - initialTriggerTime >= 100) {
                        task2.clear();
                        task.clear();
                    }
                })
                // if (nextTarget) {
                //     applyDamage(initialTarget, nextTarget);
                //     chainCount++;
                // }
            
                // 更新状态
                lastTriggerTime = currentTime;
                lastPosition = currentPos;
                // applyDamage(initialTarget, initialTarget);
                // 终止条件：达到最大连锁次数或目标死亡

                // 检查是否满足触发条件：时间间隔≥1秒 或 移动距离≥2格
                // if (
                //     currentTime - lastTriggerTime >= 5 || 
                //     currentPos.distanceTo(lastPosition) >= 2
                // ) {
                //     // 触发连锁逻辑
    
                // }
            } catch (error) {
                
            }

        }); // 每1秒（20 ticks）执行一次
    };
    
    // 寻找最近实体
    const findNearestEntity = (sourceEntity, radius) => {
        console.log('enter3')
        const world = sourceEntity.level;
        const entities = world.getEntitiesWithin(
            new needClass.AABB(
                sourceEntity.x - radius,
                sourceEntity.y - radius,
                sourceEntity.z - radius,
                sourceEntity.x + radius,
                sourceEntity.y + radius,
                sourceEntity.z + radius
            )
        ).filter(e => 
            e.isLiving() && 
            // e.id !== sourceEntity.id && // 排除自身
            e.distanceToEntity(sourceEntity) <= radius
        );
        
        // 按距离排序取最近实体
        if (entities.empty()) return null
        let nearestEntity = entities.getFirst();
        // let minDistance = radius;
        
        // entities.forEach(entity => {
        //     let distance = entity.position.distanceTo(sourceEntity.position);
        //     if (distance < minDistance) {
        //         minDistance = distance;
        //         nearestEntity = entity;
        //     }
        // });
        
        return nearestEntity;
    };

    // 服务端脚本 (server_scripts/main.js)
    const spawnLightningChain = (startEntity, endEntity) => {
        // const startPos = startEntity.position;
        // const endPos = endEntity.position;
        // const steps = 10; // 粒子段数
        // const dx = (endPos.x - startPos.x) / steps;
        // const dy = (endPos.y - startPos.y) / steps;
        // const dz = (endPos.z - startPos.z) / steps;

        // // 在两点之间生成闪电粒子
        // for (let i = 0; i <= steps; i++) {
        //     const x = startPos.x + dx * i;
        //     const y = startPos.y + dy * i;
        //     const z = startPos.z + dz * i;
            
        //     // 使用 electrical_spark 粒子（1.17+）
        //     endEntity.level.runCommandSilent(
        //         `particle minecraft:electrical_spark ${x} ${y} ${z} 0 0 0 0 1 force`
        //     );
        // }

        // // 添加末端闪光特效（可选）
        // endEntity.level.runCommandSilent(
        //     `particle minecraft:flash ${endPos.x} ${endPos.y} ${endPos.z} 0 0 0 0 1 force`
        // );
    };

    // 应用伤害
    const applyDamage = (source, target) => {
        console.log('enter4')
        target.invulnerableTime = 0;
        spawnLightningChain(source, target)
        target.attack(source, 4); // 假设每次造成4点伤害
        target.invulnerableTime = 0;
        
        console.log(`§c你被连锁攻击命中！`);
    };

    HandItemLogic.call(this, 
        6,      // damage
        false,   // releaseUsing
        TypedArrayList.empty(needClass.AttributeModifier), 
        (entity) => {  // triggerFunc
            console.log('enter1')
            try {
                startChainReaction(entity)
            } catch (error) {
                console.error(error);
                
            }

        }
    )
}

// 设置原型继承
KeraunoSoulDriver.prototype = Object.create(HandItemLogic.prototype)
KeraunoSoulDriver.prototype.constructor = KeraunoSoulDriver

// 创建实例
const keraunoSoulDriver = new KeraunoSoulDriver()